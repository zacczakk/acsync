---
phase: 12-pull-e2e-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/pull.ts
  - src/adapters/base.ts
  - src/adapters/claude-code.ts
  - src/adapters/opencode.ts
  - src/adapters/gemini.ts
  - src/adapters/codex.ts
autonomous: true
requirements: [PULL-05, PULL-06]

must_haves:
  truths:
    - "runPull pulls MCP servers from all 4 targets back to canonical JSON files"
    - "runPull pulls instructions from all 4 targets back to canonical AGENTS.md"
    - "PullItem.type includes 'mcp' and 'instruction' variants"
    - "Existing tests still pass after pipeline extension"
  artifacts:
    - path: "src/cli/pull.ts"
      provides: "MCP and instructions pull wiring"
      contains: "item.type === 'mcp'"
    - path: "src/adapters/base.ts"
      provides: "parseMCPServers abstract method"
      contains: "parseMCPServers"
  key_links:
    - from: "src/cli/pull.ts"
      to: "src/adapters/base.ts"
      via: "adapter.parseMCPServers()"
      pattern: "adapter\\.parseMCPServers"
    - from: "src/cli/pull.ts"
      to: "paths.getInstructionsPath()"
      via: "readFile + atomicWrite to instructions"
      pattern: "getInstructionsPath"
---

<objective>
Extend the pull pipeline to support MCP servers and instructions — currently pull only handles commands, agents, skills, and settings.

Purpose: Requirements PULL-05 and PULL-06 require pulling MCP and instructions from targets. The pull pipeline in pull.ts must support all 6 config types before E2E tests can cover them.
Output: Updated pull.ts with MCP + instructions discovery and write passes; adapter parseMCPServers methods for reverse-parsing target MCP configs back to canonical JSON.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/cli/pull.ts
@src/adapters/base.ts
@src/adapters/claude-code.ts
@src/adapters/opencode.ts
@src/adapters/gemini.ts
@src/adapters/codex.ts
@src/adapters/path-resolver.ts
@src/types.ts
@src/cli/canonical.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add parseMCPServers to adapters + MCP/instructions pull to pull.ts</name>
  <files>
    src/adapters/base.ts
    src/adapters/claude-code.ts
    src/adapters/opencode.ts
    src/adapters/gemini.ts
    src/adapters/codex.ts
    src/cli/pull.ts
  </files>
  <action>
**Adapter changes — add `parseMCPServers` method:**

1. In `src/adapters/base.ts` interface `Adapter`, add:
   ```
   parseMCPServers(content: string): MCPServer[];
   ```
   In `BaseAdapter`, add abstract method signature. The method takes the raw target MCP config file content and returns an array of `MCPServer` objects (the canonical format from `src/types.ts`).

2. In `src/adapters/claude-code.ts` — implement `parseMCPServers`:
   - Parse JSON content (it's a `settings.json` with `mcpServers` key)
   - For each server entry: extract `command`, `args`, `env` (stdio) or `url`, `headers` (http)
   - Infer `transport` from presence of `command` (stdio) vs `url` (http)
   - Extract `env_vars` from `env` object keys
   - Return `MCPServer[]`

3. In `src/adapters/opencode.ts` — implement `parseMCPServers`:
   - Parse JSONC content (use existing `readJsonc` from `formats/json.ts` or `jsonc-parser`)
   - MCP servers are under `mcpServers` key in `opencode.json`
   - Same extraction logic as Claude (JSON structure is similar)

4. In `src/adapters/gemini.ts` — implement `parseMCPServers`:
   - Parse JSON content (`settings.json` with `mcpServers` key)
   - Same extraction logic as Claude

5. In `src/adapters/codex.ts` — implement `parseMCPServers`:
   - Parse TOML content (use `smol-toml` which is already a dependency)
   - Codex MCP config is in `config.toml` — servers are `[mcp_servers.{name}]` sections
   - Codex only supports HTTP transport (stdio servers are filtered on push)
   - Extract `url`, `headers` from TOML sections

**Pull pipeline changes — wire MCP and instructions into pull.ts:**

6. Update `PullItem` type union to include `'mcp' | 'instruction'`:
   ```
   type: 'command' | 'agent' | 'skill' | 'settings' | 'mcp' | 'instruction';
   ```

7. In `runPull()`, after the settings discovery block, add MCP discovery:
   - Check `caps.mcp` — if true, read the MCP config file via `paths.getMCPConfigPath()`
   - If file exists, parse it with `adapter.parseMCPServers(content)` to get server list
   - For each server, create a `PullItem` with `type: 'mcp'`, `name: serverName`, `action: 'create'`
   - Handle `force` vs existing canonical: check if `configs/mcp/{name}.json` exists in projectDir
   - Handle `onlyKeys` filtering: check `mcp/{name}` key

8. In `runPull()`, add instructions discovery:
   - Check `caps.instructions` — if true, read the instructions file via `paths.getInstructionsPath()`
   - If file exists, create a `PullItem` with `type: 'instruction'`, `name: 'AGENTS'`, `action: 'create'`
   - Handle `force` vs existing canonical: check if `configs/instructions/AGENTS.md` exists
   - Handle `onlyKeys` filtering

9. In the write pass of `runPull()`, add MCP write handler:
   - For each MCP `PullItem` with `action: 'create'`:
     - Read the full MCP config file, parse with `adapter.parseMCPServers(content)`
     - Find the server matching `item.name`
     - Write it as canonical JSON to `configs/mcp/{name}.json` via `atomicWrite`
     - Canonical JSON format: `{ description, transport, command?, args?, url?, headers?, env_vars?, env? }`

10. In the write pass, add instructions write handler:
    - Read instructions file from target via `readFile(paths.getInstructionsPath())`
    - Write content as-is to `configs/instructions/AGENTS.md` via `atomicWrite` (identity passthrough — instructions have no transformation)

Import `MCP_DIR`, `INSTRUCTIONS_DIR` from `./canonical` (already exported). Import `readCanonicalMCPServers` to check for existing canonical MCP files when `force` is not set.

Do NOT import `MCPServer` as a value — it's a type. Use `import type { MCPServer }`.
  </action>
  <verify>
    `bun test` passes with zero new failures. Existing stale-and-pull.test.ts and all other tests still green.
    Verify: `grep -n "parseMCPServers" src/adapters/base.ts` shows the new method.
    Verify: `grep -n "'mcp'" src/cli/pull.ts` shows MCP items in pull pipeline.
    Verify: `grep -n "'instruction'" src/cli/pull.ts` shows instruction items in pull pipeline.
  </verify>
  <done>
    pull.ts handles all 6 config types (commands, agents, skills, settings, MCP, instructions).
    Each adapter has a parseMCPServers method that reverse-parses target MCP config to MCPServer[].
    All existing tests pass.
  </done>
</task>

</tasks>

<verification>
- `bun test` — all existing tests pass (zero regressions)
- `grep -c 'parseMCPServers' src/adapters/base.ts` returns >= 1
- `grep "'mcp'" src/cli/pull.ts` shows MCP discovery + write blocks
- `grep "'instruction'" src/cli/pull.ts` shows instruction discovery + write blocks
- TypeScript compiles: `bunx tsc --noEmit`
</verification>

<success_criteria>
- PullItem.type union includes 'mcp' and 'instruction'
- All 4 adapters implement parseMCPServers (reverse of renderMCPServers)
- runPull discovers, dry-runs, and writes MCP servers from any target
- runPull discovers, dry-runs, and writes instructions from any target
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/12-pull-e2e-tests/12-01-SUMMARY.md`
</output>
