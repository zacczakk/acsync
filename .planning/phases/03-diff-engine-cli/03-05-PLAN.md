---
phase: 03-diff-engine-cli
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/adapters/gemini.ts
  - src/adapters/codex.ts
  - src/adapters/__tests__/gemini.test.ts
  - src/adapters/__tests__/codex.test.ts
  - src/adapters/path-resolver.ts
  - src/cli/orchestrator.ts
autonomous: true
gap_closure: true
requirements: [RNDR-13, SECR-01, CLI-04]

must_haves:
  truths:
    - "Skills pushed to ~/.gemini/skills/ and ~/.codex/skills/ after push"
    - "check shows no MCP drift for Claude/Gemini after push (no perpetual mismatch)"
    - "Rendered MCP configs contain ${VAR} placeholders as-is (no substitution)"
  artifacts:
    - path: "src/adapters/gemini.ts"
      provides: "getCapabilities() with skills: true"
      contains: "skills: true"
    - path: "src/adapters/codex.ts"
      provides: "getCapabilities() with skills: true"
      contains: "skills: true"
    - path: "src/adapters/path-resolver.ts"
      provides: "rawSkillsDir for gemini → ~/.gemini/skills/, codex → ~/.codex/skills/"
      contains: "~/.gemini/skills/"
    - path: "src/cli/orchestrator.ts"
      provides: "No injectSecrets call in runPush; no loadSecrets setup"
  key_links:
    - from: "src/adapters/gemini.ts getCapabilities()"
      to: "orchestrator skills processing gate"
      via: "caps.skills === true"
      pattern: "skills: true"
    - from: "src/cli/orchestrator.ts runPush"
      to: "rendered content written as-is"
      via: "atomicWrite without injectSecrets"
      pattern: "atomicWrite\\(op\\.targetPath, content"
---

<objective>
Fix two remaining UAT gaps:

1. **Skills for Gemini/Codex** — Both adapters have `skills: false` so orchestrator skips skills entirely. Confirmed: `~/.gemini/skills/` and `~/.codex/skills/` exist with content (vercel-react-best-practices, web-design-guidelines). Enable skills in both adapters and ensure path-resolver points to the right dirs.

2. **Remove secret injection** — `injectSecrets` runs in `runPush` only; manifest stores pre-inject hash; on-disk content has injected values; next `check` always shows drift. User decision: write `${VAR}` placeholders as-is. Each CLI reads env vars natively (Claude Code, Gemini support `${VAR}` syntax). Remove `injectSecrets` call and `loadSecrets` setup from `runPush`.

Purpose: Skills land in all 4 CLIs. `check` after `push` shows 0 MCP drift.
Output: Both adapters with skills: true, correct skill paths, orchestrator without secret injection.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-diff-engine-cli/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable skills in Gemini + Codex adapters; fix skill paths</name>
  <files>
    src/adapters/gemini.ts
    src/adapters/codex.ts
    src/adapters/path-resolver.ts
    src/adapters/__tests__/gemini.test.ts
    src/adapters/__tests__/codex.test.ts
  </files>
  <action>
**gemini.ts** — `getCapabilities()`: change `skills: false` → `skills: true`

**codex.ts** — `getCapabilities()`: change `skills: false` → `skills: true`

**path-resolver.ts** — `rawSkillsDir()` currently has opencode case and a default fallback to `{baseDir}/skills/`. The default produces `~/.gemini/skills/` and `~/.codex/skills/` correctly (baseDir for gemini = `~/.gemini`, codex = `~/.codex`). Verify the default case is correct:
- gemini: `~/.gemini` + `/skills/` = `~/.gemini/skills/` ✓
- codex: `~/.codex` + `/skills/` = `~/.codex/skills/` ✓

No path-resolver change needed — confirm by inspection, add a comment if helpful.

**gemini.test.ts** — add a skills capabilities test:
```typescript
it('declares skills capability', () => {
  const caps = new GeminiAdapter().getCapabilities();
  expect(caps.skills).toBe(true);
});
```

**codex.test.ts** — add same test:
```typescript
it('declares skills capability', () => {
  const caps = new CodexAdapter().getCapabilities();
  expect(caps.skills).toBe(true);
});
```

Also add a skill path assertion for each adapter using the adapter's `getPaths().getSkillsDir()`:
- Gemini: `expect(adapter.getPaths().getSkillsDir()).toBe(path.join(HOME, '.gemini/skills'))`
- Codex: `expect(adapter.getPaths().getSkillsDir()).toBe(path.join(HOME, '.codex/skills'))`

Run `bun test src/adapters/__tests__/gemini.test.ts src/adapters/__tests__/codex.test.ts`.
  </action>
  <verify>bun test src/adapters/__tests__/gemini.test.ts src/adapters/__tests__/codex.test.ts</verify>
  <done>Gemini and Codex adapters report skills: true. Skill paths resolve to ~/.gemini/skills/ and ~/.codex/skills/. Tests green.</done>
</task>

<task type="auto">
  <name>Task 2: Remove secret injection from orchestrator</name>
  <files>
    src/cli/orchestrator.ts
  </files>
  <action>
In `runPush` (orchestrator.ts):

1. Remove lines 536-537 (loadSecrets setup):
   ```typescript
   const secretsResult = await loadSecrets(join(projectDir, '.env'));
   const secrets = secretsResult.secrets;
   ```

2. Remove the injectSecrets call at line 650-652:
   ```typescript
   // Inject secrets
   const injected = injectSecrets(content, secrets);
   content = injected.result;
   ```
   Replace with nothing — `content` is used directly as-is.

3. Remove the now-unused imports at top of file:
   - `loadSecrets` from `'../secrets/env-loader'`
   - `injectSecrets` from `'../secrets/injector'`

After these removals: rendered content (with `${VAR}` placeholders) is written verbatim. `check` hashes the same rendered string that was written, so manifest hash matches on-disk hash → no perpetual drift.

Note: The `loadSecrets` import line is line 14 and `injectSecrets` is line 15. Remove both. If `loadSecrets` or `injectSecrets` are used elsewhere in the file, only remove from runPush — but they are not (grep confirms single-use).

Run `bun test` to confirm full suite green.
  </action>
  <verify>bun test && grep -n "injectSecrets\|loadSecrets" src/cli/orchestrator.ts</verify>
  <done>Full test suite passes. `grep` returns no matches for injectSecrets/loadSecrets in orchestrator.ts. Rendered output contains ${VAR} placeholders as written.</done>
</task>

</tasks>

<verification>
1. `bun test` — full suite green
2. `bun src/cli/index.ts push --force --type skill --dry-run` — shows skill ops for claude-code, opencode, gemini, codex
3. `bun src/cli/index.ts push --force && bun src/cli/index.ts check` — MCP entries show 0 drift (no perpetual mismatch)
4. `ls ~/.gemini/skills/` and `ls ~/.codex/skills/` — skills present after push
</verification>

<success_criteria>
- GeminiAdapter.getCapabilities().skills === true
- CodexAdapter.getCapabilities().skills === true
- Skills write to ~/.gemini/skills/{name}/SKILL.md and ~/.codex/skills/{name}/SKILL.md
- No injectSecrets or loadSecrets in orchestrator.ts runPush
- check after push shows 0 MCP drift
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-diff-engine-cli/03-05-SUMMARY.md`
</output>
