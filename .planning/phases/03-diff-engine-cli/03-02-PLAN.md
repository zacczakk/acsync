---
phase: 03-diff-engine-cli
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/cli/index.ts
  - src/cli/check.ts
  - src/cli/push.ts
  - src/cli/orchestrator.ts
  - src/cli/__tests__/check.test.ts
  - src/cli/__tests__/push.test.ts
  - src/cli/__tests__/orchestrator.test.ts
  - package.json
autonomous: true
requirements:
  - CLI-01
  - CLI-02
  - CLI-03
  - CLI-04
  - CLI-05
  - CLI-06
  - CLI-07
  - CLI-08
  - CLI-09
  - FILE-03

must_haves:
  truths:
    - "acsync check detects drift and exits with code 2"
    - "acsync check --pretty shows colored grouped output"
    - "acsync check outputs JSON by default (agent-first)"
    - "acsync push renders + writes all configs with rollback on failure"
    - "acsync push --dry-run shows plan without writing"
    - "acsync push prompts for confirmation by default, --force skips"
    - "acsync push --target claude scopes to single target"
    - "acsync push --type commands scopes to config type"
    - "Exit codes: 0=success, 1=error, 2=drift"
  artifacts:
    - path: "src/cli/index.ts"
      provides: "Commander.js CLI entry point with check/push subcommands"
      exports: ["program"]
    - path: "src/cli/check.ts"
      provides: "check subcommand — diff-only, exit code 2 on drift"
      exports: ["checkCommand"]
    - path: "src/cli/push.ts"
      provides: "push subcommand — render + write with rollback"
      exports: ["pushCommand"]
    - path: "src/cli/orchestrator.ts"
      provides: "Sync orchestrator — renders canonical items, computes hashes, drives diff, executes writes"
      exports: ["runCheck", "runPush"]
  key_links:
    - from: "src/cli/orchestrator.ts"
      to: "src/core/diff.ts"
      via: "calls calculateDiff for each target"
      pattern: "calculateDiff"
    - from: "src/cli/orchestrator.ts"
      to: "src/core/rollback.ts"
      via: "creates backups before each write, restoreAll on failure"
      pattern: "createBackup.*restoreAll"
    - from: "src/cli/orchestrator.ts"
      to: "src/core/manifest.ts"
      via: "loads manifest before diff, saves after push"
      pattern: "loadManifest.*saveManifest"
    - from: "src/cli/push.ts"
      to: "src/cli/orchestrator.ts"
      via: "push command delegates to runPush"
      pattern: "runPush"
    - from: "src/cli/index.ts"
      to: "src/cli/check.ts"
      via: "registers check subcommand"
      pattern: "checkCommand"
---

<objective>
CLI shell with check/push subcommands, push orchestration loop with rollback, and all flags (--pretty, --dry-run, --force, --target, --type).

Purpose: Wire Plan 01's diff/manifest/rollback engine into a usable CLI binary (`acsync`). This is the user-facing entry point that agents and humans interact with.
Output: Working `acsync check` and `acsync push` commands with proper exit codes
</objective>

<execution_context>
@/Users/m332023/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/m332023/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-diff-engine-cli/03-CONTEXT.md
@.planning/phases/03-diff-engine-cli/03-01-SUMMARY.md

Existing codebase:
- src/core/manifest.ts — loadManifest, saveManifest, updateManifestItem (from Plan 01)
- src/core/diff.ts — compareHashes, calculateDiff (from Plan 01)
- src/core/rollback.ts — createBackup, restoreBackup, restoreAll, cleanupAll (from Plan 01)
- src/core/formatter.ts — formatDiffJson, formatDiffPretty, formatPushResult, formatCheckResult (from Plan 01)
- src/adapters/ — All 4 adapter classes with renderCommand, renderAgent, renderMCPServers, renderInstructions
- src/adapters/path-resolver.ts — AdapterPathResolver for target file paths
- src/infra/hash.ts — hashFile for content hashing
- src/infra/atomic-write.ts — atomicWrite for crash-safe writes
- src/infra/exclusion.ts — createExclusionFilter for gsd-* exclusion
- src/secrets/env-loader.ts — loadSecrets
- src/secrets/injector.ts — injectSecrets
- src/formats/ — readJson, writeJson, readJsonc, readToml, parseFrontmatter
- package.json already has commander@^14.0.3
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sync orchestrator — the engine that drives check and push</name>
  <files>src/cli/orchestrator.ts, src/cli/__tests__/orchestrator.test.ts</files>
  <action>
Create `src/cli/orchestrator.ts` — the core engine that both `check` and `push` delegate to. This module reads canonical configs, renders them through adapters, computes hashes, runs the diff engine, and (for push) executes writes with rollback.

**Types for orchestrator:**

```typescript
interface SyncOptions {
  targets?: TargetName[];        // --target flag (all if empty)
  types?: ItemType[];            // --type flag (all if empty)
  dryRun?: boolean;              // --dry-run
  force?: boolean;               // --force (skip confirmation)
  pretty?: boolean;              // --pretty (human output)
  projectDir?: string;           // project root (default cwd)
}

interface CheckResult {
  diffs: DiffResult[];
  hasDrift: boolean;
  output: string;                // formatted output (JSON or pretty)
}

interface PushResult {
  diffs: DiffResult[];
  written: number;
  failed: number;
  rolledBack: boolean;
  output: string;
}
```

**`runCheck(options: SyncOptions): Promise<CheckResult>`:**

1. Load manifest via `loadManifest(options.projectDir)`
2. Discover canonical configs:
   - Read canonical commands from `configs/common/commands/` (glob for *.md files, parse frontmatter for metadata)
   - Read canonical agents from `configs/common/agents/` (glob for *.md files)
   - Read canonical MCP from `configs/common/mcp.json` (or wherever stored — check actual repo structure)
   - Read canonical instructions (AGENTS.md + CLI addendums)
   - **Important**: Use `createExclusionFilter` to skip gsd-* items
3. For each target (filtered by options.targets):
   a. Instantiate adapter (ClaudeCodeAdapter, etc.)
   b. Render each canonical item through adapter → get RenderedFile
   c. Hash rendered content (SHA-256 of the string)
   d. Hash existing target file on disk (if exists) via `hashFile`
   e. Build source items array with hashes
   f. Build target hashes map from disk
   g. Call `calculateDiff(sourceItems, targetHashes, manifest, target)`
4. Filter by options.types if specified
5. Format output via `formatCheckResult(diffs, options.pretty)`
6. Return `{ diffs, hasDrift, output }`

**Discovery helper — `discoverCanonicalItems(projectDir: string, types?: ItemType[])`:**

Read the canonical config directory structure. For this project:
- Commands: `configs/common/commands/*.md` — parse with parseFrontmatter, extract name from filename
- Agents: `configs/common/agents/*.md` — same
- MCP: determine where MCP config lives (likely `configs/common/mcp.json` or similar)
- Instructions: `AGENTS.md` (base) + `configs/*/addendum.md` pattern
- Skills: `configs/common/skills/*/` directories

If the canonical paths don't exist in the current project, handle gracefully (empty arrays).

**`runPush(options: SyncOptions): Promise<PushResult>`:**

1. Run `runCheck(options)` first to get diffs
2. If no drift → return early (nothing to push)
3. If dryRun → format plan and return (FILE-03)
4. If !force → confirmation prompt needed (but CLI layer handles this, not orchestrator — orchestrator just returns plan for CLI to present)
5. For each target with operations:
   a. For each create/update operation:
      - `createBackup(targetPath)` → collect BackupInfo[]
      - Render canonical item through adapter
      - If secrets needed: `injectSecrets(rendered, secrets)`
      - `atomicWrite(targetPath, content)`
      - `updateManifestItem(manifest, ...)`
   b. On ANY error during writes:
      - `restoreAll(backups)` — verbose per CONTEXT.md decision
      - Report error + rollback status
      - Return with `rolledBack: true`
6. On success: `cleanupAll(backups)`, `saveManifest(manifest)`
7. Format output and return

**Note on rendering pipeline**: The orchestrator ties together the full pipeline: read canonical → render through adapter → hash → diff → write. It's the glue between all prior phases.

**Tests (src/cli/__tests__/orchestrator.test.ts):**
- Test `runCheck` with a temp project dir containing some canonical configs and some already-synced targets
- Test `runPush` dry-run mode (no files written)
- Test `runPush` with rollback (mock a write failure, verify backup files restored)
- Use real filesystem with mkdtempSync
- At minimum 8-10 tests covering: empty project, all synced, drift detected, push success, push failure + rollback
  </action>
  <verify>Run `bun test src/cli/__tests__/orchestrator.test.ts` — all tests pass. Test that `runCheck` returns correct hasDrift boolean. Test that failed push triggers rollback.</verify>
  <done>Orchestrator reads canonical configs, renders through adapters, diffs against targets, and pushes with rollback. Both runCheck and runPush work end-to-end in tests.</done>
</task>

<task type="auto">
  <name>Task 2: CLI entry point with check and push subcommands</name>
  <files>src/cli/index.ts, src/cli/check.ts, src/cli/push.ts, src/cli/__tests__/check.test.ts, src/cli/__tests__/push.test.ts, package.json</files>
  <action>
Per CONTEXT.md locked decisions:
- Binary name: `acsync`
- Two subcommands only: `acsync check` and `acsync push`
- JSON default output (agent-first), `--pretty` for humans
- Target identifiers: claude, gemini, codex, opencode
- Config type identifiers (plural): commands, agents, mcps, instructions, skills
- Flags: singular repeatable (`--target claude --target codex`)
- Exit codes: 0=success, 1=error, 2=drift

**CLI Entry (src/cli/index.ts):**

Use Commander.js (already in package.json). Set up:
```typescript
import { Command } from 'commander';
import { checkCommand } from './check';
import { pushCommand } from './push';

const program = new Command()
  .name('acsync')
  .description('Agent Config Sync — render, diff, and push canonical configs to CLI targets')
  .version('1.0.0');

program.addCommand(checkCommand);
program.addCommand(pushCommand);

// Exit override for proper exit codes
program.exitOverride();

export { program };
```

Add to package.json:
```json
{
  "bin": {
    "acsync": "./src/cli/index.ts"
  }
}
```

Since we're using Bun, the .ts file is directly executable. Add a shebang: `#!/usr/bin/env bun`

**Check Command (src/cli/check.ts):**

```typescript
const checkCommand = new Command('check')
  .description('Detect drift between canonical and target configs')
  .option('--pretty', 'Human-readable colored output (default: JSON)')
  .option('--target <name>', 'Scope to specific target (repeatable)', collect, [])
  .option('--type <name>', 'Scope to config type (repeatable)', collect, [])
  .action(async (options) => {
    // Validate targets: must be 'claude', 'gemini', 'codex', 'opencode'
    // Validate types: must be 'commands', 'agents', 'mcps', 'instructions', 'skills'
    // Map user-facing names to internal: 'claude' → 'claude-code' as TargetName
    const result = await runCheck({
      targets: mapTargets(options.target),
      types: mapTypes(options.type),
      pretty: options.pretty,
    });
    process.stdout.write(result.output + '\n');
    process.exit(result.hasDrift ? 2 : 0);
  });
```

Helper: `collect(value, previous)` for Commander repeatable options.
Helper: `mapTargets(['claude', 'opencode'])` → `['claude-code', 'opencode']` (map 'claude' → 'claude-code', others pass through).
Helper: `mapTypes(['commands'])` → `['command']` (strip trailing 's' for internal type).

**Push Command (src/cli/push.ts):**

```typescript
const pushCommand = new Command('push')
  .description('Render and write configs to target locations')
  .option('--pretty', 'Human-readable colored output (default: JSON)')
  .option('--target <name>', 'Scope to specific target (repeatable)', collect, [])
  .option('--type <name>', 'Scope to config type (repeatable)', collect, [])
  .option('--dry-run', 'Show execution plan without writing')
  .option('--force', 'Skip confirmation prompt')
  .action(async (options) => {
    const syncOpts = {
      targets: mapTargets(options.target),
      types: mapTypes(options.type),
      dryRun: options.dryRun,
      force: options.force,
      pretty: options.pretty,
    };

    // If not dry-run and not force, show plan and prompt
    if (!options.dryRun && !options.force) {
      const check = await runCheck(syncOpts);
      if (!check.hasDrift) {
        process.stdout.write(check.output + '\n');
        process.exit(0);
      }
      // Show plan
      process.stdout.write(check.output + '\n');
      // Confirmation prompt (use readline or process.stdin)
      const confirmed = await confirm('Proceed with push?');
      if (!confirmed) {
        process.stderr.write('Push cancelled.\n');
        process.exit(0);
      }
    }

    const result = await runPush(syncOpts);
    process.stdout.write(result.output + '\n');
    process.exit(result.failed > 0 ? 1 : 0);
  });
```

Implement `confirm(question: string): Promise<boolean>` using readline interface (read single line from stdin, check y/Y/yes).

**Target name mapping:**
- User types: `claude`, `gemini`, `codex`, `opencode`
- Internal TargetName: `claude-code`, `gemini`, `codex`, `opencode`
- Only `claude` → `claude-code` needs mapping; others are identity

**Type name mapping:**
- User types: `commands`, `agents`, `mcps`, `instructions`, `skills`
- Internal ItemType: `command`, `agent`, `mcp`, `instruction`, `skill`
- Strip trailing 's' (or 'cps' → 'cp' for mcps → 'mcp' explicitly)

**Error handling:**
Wrap the entire action in try/catch. On error:
- If SyncError: format with category + suggestion (simple version of vsync's error-formatter)
- Exit code 1

**Tests:**
- check.test.ts: Test that check command creates proper SyncOptions from CLI flags, validates target/type names, maps names correctly
- push.test.ts: Test that push command creates proper SyncOptions, test dry-run flag sets dryRun=true, test force flag sets force=true
- Don't test full E2E through Commander (that's integration territory) — test the logic functions (mapTargets, mapTypes, collect)
  </action>
  <verify>Run `bun test src/cli/__tests__/` — all CLI tests pass. Run `bun test` — full suite green. Run `bun src/cli/index.ts --help` to verify Commander output shows check/push subcommands. Run `bun src/cli/index.ts check --help` to verify flags.</verify>
  <done>acsync CLI works with check/push subcommands, all flags (--pretty, --dry-run, --force, --target, --type), proper exit codes (0/1/2), JSON default output. Full test suite passes.</done>
</task>

</tasks>

<verification>
- `bun test` — full suite passes (all prior + new tests)
- `bun src/cli/index.ts --help` shows acsync with check/push subcommands
- `bun src/cli/index.ts check --help` shows --pretty, --target, --type flags
- `bun src/cli/index.ts push --help` shows --pretty, --target, --type, --dry-run, --force flags
- Exit code 2 when drift detected via check
- Exit code 0 when no drift
- JSON output by default (no --pretty flag)
</verification>

<success_criteria>
- acsync check detects drift with exit code 2, outputs JSON by default
- acsync push renders + writes with rollback on failure
- --dry-run shows plan without writing
- --force skips confirmation
- --target and --type scope operations
- --pretty shows colored human output
- Exit codes: 0=success, 1=error, 2=drift
</success_criteria>

<output>
After completion, create `.planning/phases/03-diff-engine-cli/03-02-SUMMARY.md`
</output>
