---
phase: 02-renderers-secrets
plan: 03
type: execute
wave: 3
depends_on: [02-01, 02-02]
files_modified:
  - src/adapters/claude-code.ts
  - src/adapters/opencode.ts
  - src/adapters/gemini.ts
  - src/adapters/codex.ts
  - src/adapters/__tests__/mcp-claude-code.test.ts
  - src/adapters/__tests__/mcp-opencode.test.ts
  - src/adapters/__tests__/mcp-gemini.test.ts
  - src/adapters/__tests__/mcp-codex.test.ts
  - src/adapters/__tests__/instructions.test.ts
autonomous: true
requirements: [RNDR-09, RNDR-10, RNDR-11, RNDR-12, RNDR-13, RNDR-14]

must_haves:
  truths:
    - "Full MCP server list renders to correct settings format per target"
    - "Claude MCP produces JSON with mcpServers key and secret placeholders"
    - "OpenCode MCP produces JSONC with mcp key, local/remote types, environment key, command as array"
    - "Gemini MCP produces JSON with mcpServers key (same shape as Claude)"
    - "Codex MCP produces TOML with mcp_servers key, HTTP-only (stdio servers skipped)"
    - "Instructions render as base AGENTS.md + CLI-specific addendum concatenation"
    - "disabledFor filtering excludes servers from target-specific output"
  artifacts:
    - path: "src/adapters/claude-code.ts"
      provides: "renderMCPServers method — complete JSON settings"
      contains: "renderMCPServers"
    - path: "src/adapters/opencode.ts"
      provides: "renderMCPServers method — JSONC with comment preservation"
      contains: "renderMCPServers"
    - path: "src/adapters/gemini.ts"
      provides: "renderMCPServers method — JSON settings"
      contains: "renderMCPServers"
    - path: "src/adapters/codex.ts"
      provides: "renderMCPServers method — TOML with HTTP-only filter"
      contains: "renderMCPServers"
  key_links:
    - from: "src/adapters/opencode.ts"
      to: "src/formats/jsonc.ts"
      via: "modifyJsonc for JSONC comment-preserving edits"
      pattern: "modifyJsonc"
    - from: "src/adapters/opencode.ts"
      to: "src/secrets/env-var-transformer.ts"
      via: "EnvVarTransformer.toOpenCode for env var format conversion"
      pattern: "EnvVarTransformer"
    - from: "src/adapters/codex.ts"
      to: "src/formats/toml.ts"
      via: "writeToml for TOML serialization"
      pattern: "writeToml"
    - from: "src/adapters/claude-code.ts"
      to: "src/formats/json.ts"
      via: "writeJson for JSON serialization"
      pattern: "writeJson"
---

<objective>
MCP server rendering for all 4 targets + instructions renderer + skill copy support.

Purpose: Complete the adapter classes with MCP serialization (the most complex rendering — different format per target), instruction concatenation, and skill directory support. After this plan, all RNDR-* and SECR-* requirements are satisfied.

Output: All 4 adapters fully implemented with renderMCPServers + renderInstructions. Tests for MCP rendering per target.
</objective>

<execution_context>
@/Users/m332023/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/m332023/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-renderers-secrets/02-RESEARCH.md
@.planning/phases/02-renderers-secrets/02-CONTEXT.md
@.planning/phases/02-renderers-secrets/02-01-SUMMARY.md
@.planning/phases/02-renderers-secrets/02-02-SUMMARY.md
@src/types.ts
@src/adapters/base.ts
@src/adapters/claude-code.ts
@src/adapters/opencode.ts
@src/adapters/gemini.ts
@src/adapters/codex.ts
@src/secrets/env-var-transformer.ts
@src/formats/jsonc.ts
@src/formats/json.ts
@src/formats/toml.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP rendering for Claude Code + OpenCode</name>
  <files>
    src/adapters/claude-code.ts
    src/adapters/opencode.ts
    src/adapters/__tests__/mcp-claude-code.test.ts
    src/adapters/__tests__/mcp-opencode.test.ts
  </files>
  <action>
    **1. Implement `ClaudeCodeAdapter.renderMCPServers`:**

    Replace the stub with full implementation. Port from vsync `ClaudeCodeAdapter.writeMCPServers`.

    - Input: `MCPServer[]` + optional `existingContent` (existing settings.json string)
    - Output: complete JSON string for `~/.claude/settings.json`
    - Build `mcpServers` object: key = server name, value = server config
    - For stdio servers: `{ command: server.command, args: server.args, env: server.env }`
    - For http servers: `{ url: server.url, headers: server.headers }`
    - Filter out servers where `disabledFor` includes `'claude-code'`
    - If `existingContent` provided: parse it, merge `mcpServers` key, preserve other keys (like permissions)
    - Use `writeJson` from Phase 1 for output
    - Env vars stay as `${VAR}` placeholders (Claude's native format — no conversion needed)

    **2. Implement `OpenCodeAdapter.renderMCPServers`:**

    Port from vsync `OpenCodeAdapter.writeMCPServers`. This is the most complex — JSONC with comment preservation.

    - Input: `MCPServer[]` + optional `existingContent` (existing opencode.jsonc string)
    - Output: JSONC string with `mcp` key containing all servers
    - Use `modifyJsonc` from Phase 1 for comment-preserving edits
    - For each server:
      ```
      config.type = server.transport === 'stdio' ? 'local' : 'remote'
      if stdio: config.command = [server.command, ...(server.args ?? [])]
      if http: config.url = server.url
      if server.env: config.environment = EnvVarTransformer.toOpenCode(server.env)
      ```
    - Use `EnvVarTransformer.toOpenCode()` to convert `${VAR}` → `{env:VAR}` in env values
    - Filter out servers where `disabledFor` includes `'opencode'`
    - If no `existingContent`: start with `'{}'`
    - Ensure `mcp` object exists before adding servers

    **3. Tests:**

    - `mcp-claude-code.test.ts`:
      - Renders stdio server correctly (command, args, env with ${VAR} placeholders)
      - Renders http server correctly (url, headers)
      - Filters out disabledFor servers
      - Merges with existing settings.json (preserves non-MCP keys)
      - Empty server list → empty mcpServers object

    - `mcp-opencode.test.ts`:
      - Renders stdio as local type with command array
      - Renders http as remote type with url
      - Converts env vars to OpenCode format ({env:VAR})
      - Filters out disabledFor servers
      - Preserves existing JSONC comments when merging
  </action>
  <verify>
    Run `bun test src/adapters/__tests__/mcp-claude-code.test.ts src/adapters/__tests__/mcp-opencode.test.ts` — all pass.
  </verify>
  <done>
    - ClaudeCodeAdapter.renderMCPServers produces valid JSON with mcpServers key
    - OpenCodeAdapter.renderMCPServers produces JSONC with mcp key, correct types, env var conversion
    - Both handle existingContent merge without data loss
    - disabledFor filtering works correctly
    - 10+ tests verify MCP rendering for both targets
  </done>
</task>

<task type="auto">
  <name>Task 2: MCP rendering for Gemini + Codex, instructions renderer</name>
  <files>
    src/adapters/gemini.ts
    src/adapters/codex.ts
    src/adapters/__tests__/mcp-gemini.test.ts
    src/adapters/__tests__/mcp-codex.test.ts
    src/adapters/__tests__/instructions.test.ts
  </files>
  <action>
    **1. Implement `GeminiAdapter.renderMCPServers`:**

    Same shape as Claude Code — JSON with `mcpServers` key (per research: confirmed from `~/.gemini/settings.json`).

    - Input: `MCPServer[]` + optional `existingContent`
    - Output: JSON string with `mcpServers` key
    - Same serialization logic as Claude: stdio gets command/args/env, http gets url/headers
    - Env vars stay as `${VAR}` (Gemini uses same format as Claude)
    - Filter out servers where `disabledFor` includes `'gemini'`
    - Merge with existing settings if provided

    **2. Implement `CodexAdapter.renderMCPServers`:**

    Port from vsync `CodexAdapter.writeMCPServers`. TOML format, HTTP-only.

    - Input: `MCPServer[]` + optional `existingContent`
    - Output: TOML string with `mcp_servers` section
    - **HTTP-only**: skip all servers where `transport === 'stdio'` (per user decision + research)
    - Filter out servers where `disabledFor` includes `'codex'`
    - Per server (HTTP only):
      ```toml
      [mcp_servers.{name}]
      url = "https://..."
      env_vars = ["VAR1", "VAR2"]        # from envVars array
      bearer_token_env_var = "TOKEN_VAR"  # if headers has Authorization with ${VAR}
      ```
    - Extract `bearer_token_env_var` from headers: if `headers.Authorization` matches `Bearer ${VAR}`, extract VAR name
    - Use `writeToml` from Phase 1 for serialization
    - If no HTTP servers remain after filtering: return empty string or minimal TOML

    **3. Implement instructions rendering** (already default in BaseAdapter, verify or customize):

    The BaseAdapter default `renderInstructions(baseMd, addendumMd)` concatenates with double newline.
    - Verify this works for all 4 targets
    - Path expansion (`~/ → homedir`) should be applied to the concatenated output via `expandPaths()`
    - Add a helper or override if any target needs special handling

    For RNDR-14 (skills): Add a `getSkillsDir()` path on PathResolver (already planned in Plan 01). Skill copying is a directory copy operation — the adapter provides the target directory path, the caller uses `fs.cp` or similar. No render logic needed — skills are copied verbatim. Document this in the adapter's capabilities.

    **4. Tests:**

    - `mcp-gemini.test.ts`:
      - Renders same shape as Claude (mcpServers key, JSON format)
      - Env vars stay as ${VAR}
      - Filters disabledFor
      - Merges with existing settings

    - `mcp-codex.test.ts`:
      - Skips stdio servers entirely (only HTTP in output)
      - Produces TOML with mcp_servers section
      - Extracts bearer_token_env_var from Authorization header
      - env_vars array contains variable names (no ${} wrapping)
      - Empty output when all servers are stdio

    - `instructions.test.ts`:
      - Concatenates base + addendum with separator
      - Path expansion converts ~ to homedir
      - Works for each adapter (shared test with all 4 instances)
  </action>
  <verify>
    Run `bun test src/adapters/__tests__/mcp-gemini.test.ts src/adapters/__tests__/mcp-codex.test.ts src/adapters/__tests__/instructions.test.ts` — all pass.
    Run `bun test` — ALL project tests pass (full suite including Phase 1).
  </verify>
  <done>
    - GeminiAdapter.renderMCPServers produces JSON with mcpServers key (same shape as Claude)
    - CodexAdapter.renderMCPServers produces TOML, HTTP-only, with bearer_token_env_var extraction
    - Instructions rendering concatenates base + addendum with path expansion
    - Skill copying supported via PathResolver paths (verbatim directory copy, no render logic)
    - All MCP rendering stubs replaced with real implementations
    - Full test suite passes
  </done>
</task>

</tasks>

<verification>
- `bun test` — full suite passes (all Phase 1 + Phase 2 tests)
- Each adapter has complete renderCommand, renderAgent, renderMCPServers, renderInstructions
- No stubs remain in any adapter
- MCP output matches target format expectations from research
- Codex correctly skips stdio servers
- OpenCode correctly converts env var format
</verification>

<success_criteria>
- All 14 RNDR requirements satisfied (commands, agents, MCP, instructions, skills for 4 targets)
- All 3 SECR requirements satisfied (env loading + injection + format conversion from Plan 01)
- Full test suite passes with no regressions
- Adapters are pure renderers — no file I/O
</success_criteria>

<output>
After completion, create `.planning/phases/02-renderers-secrets/02-03-SUMMARY.md`
</output>
