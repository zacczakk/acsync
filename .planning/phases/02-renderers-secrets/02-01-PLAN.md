---
phase: 02-renderers-secrets
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/errors.ts
  - src/secrets/env-loader.ts
  - src/secrets/injector.ts
  - src/secrets/env-var-transformer.ts
  - src/adapters/base.ts
  - src/adapters/path-resolver.ts
  - src/secrets/__tests__/env-loader.test.ts
  - src/secrets/__tests__/injector.test.ts
  - src/secrets/__tests__/env-var-transformer.test.ts
autonomous: true
requirements: [SECR-01, SECR-02, SECR-03]

must_haves:
  truths:
    - "Secrets load from .env file at a specified path and return key-value pairs"
    - "Secret placeholders in rendered content get replaced with actual values"
    - "Unresolved placeholders produce warnings but remain intact"
    - "Env var syntax converts correctly between claude-code, opencode, gemini, and codex formats"
    - "Secret values redact to **** in dry-run output"
  artifacts:
    - path: "src/secrets/env-loader.ts"
      provides: "loadSecrets function — parse KEY=VALUE .env file"
      exports: ["loadSecrets"]
    - path: "src/secrets/injector.ts"
      provides: "injectSecrets and redactSecrets functions"
      exports: ["injectSecrets", "redactSecrets"]
    - path: "src/secrets/env-var-transformer.ts"
      provides: "EnvVarTransformer class — format-aware env var conversion"
      exports: ["EnvVarTransformer", "EnvVarFormat"]
    - path: "src/types.ts"
      provides: "BaseItem, MCPServer, TargetName, RenderedFile, AdapterCapabilities types"
      contains: "TargetName"
    - path: "src/adapters/base.ts"
      provides: "ToolAdapter interface + BaseAdapter abstract class"
      exports: ["ToolAdapter", "BaseAdapter"]
    - path: "src/adapters/path-resolver.ts"
      provides: "AdapterPathResolver — centralized target path construction"
      exports: ["AdapterPathResolver"]
  key_links:
    - from: "src/secrets/injector.ts"
      to: "src/secrets/env-loader.ts"
      via: "consumes Record<string, string> from loadSecrets"
      pattern: "Record<string, string>"
    - from: "src/adapters/base.ts"
      to: "src/adapters/path-resolver.ts"
      via: "BaseAdapter creates AdapterPathResolver in constructor"
      pattern: "AdapterPathResolver"
    - from: "src/adapters/base.ts"
      to: "src/types.ts"
      via: "imports ToolAdapter, TargetName, AdapterCapabilities"
      pattern: "import.*ToolAdapter"
---

<objective>
Secret handling infrastructure + adapter base classes for Phase 2 rendering.

Purpose: Build the foundation all renderers need — env var loading/injection/format-conversion, plus the BaseAdapter/ToolAdapter class hierarchy and PathResolver ported from vsync. This must exist before any target-specific rendering code.

Output: `src/secrets/` module (env-loader, injector, env-var-transformer), `src/adapters/base.ts` + `path-resolver.ts`, extended `src/types.ts` with rendering types.
</objective>

<execution_context>
@/Users/m332023/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/m332023/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-renderers-secrets/02-RESEARCH.md
@.planning/phases/02-renderers-secrets/02-CONTEXT.md
@src/types.ts
@src/errors.ts
@src/formats/jsonc.ts
@src/formats/markdown.ts
@src/formats/toml.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Types, secrets module (env-loader + injector + EnvVarTransformer)</name>
  <files>
    src/types.ts
    src/errors.ts
    src/secrets/env-loader.ts
    src/secrets/injector.ts
    src/secrets/env-var-transformer.ts
    src/secrets/__tests__/env-loader.test.ts
    src/secrets/__tests__/injector.test.ts
    src/secrets/__tests__/env-var-transformer.test.ts
  </files>
  <action>
    **1. Extend `src/types.ts`** with rendering types (per user decision: adopt vsync's normalized interchange models):

    ```typescript
    export type TargetName = 'claude-code' | 'opencode' | 'gemini' | 'codex';

    // Canonical interchange model (ported from vsync BaseItem)
    export interface CanonicalItem {
      name: string;
      content: string;               // body after frontmatter
      metadata: Record<string, unknown>;  // frontmatter data
      hash?: string;
      supportFiles?: SupportFile[];
    }

    export interface SupportFile {
      relativePath: string;
      content: string;
    }

    // Canonical MCP server (ported from vsync MCPServer)
    export interface MCPServer {
      name: string;
      description?: string;
      transport: 'stdio' | 'http';
      command?: string;          // stdio only
      args?: string[];           // stdio only
      url?: string;              // http only
      headers?: Record<string, string>;  // http only
      env?: Record<string, string>;
      envVars?: string[];        // var names needed
      disabledFor?: TargetName[];
    }

    // Rendered output from an adapter
    export interface RenderedFile {
      relativePath: string;
      content: string;
    }

    // Per-target capability matrix
    export interface AdapterCapabilities {
      commands: boolean;
      agents: boolean;
      mcp: boolean;
      instructions: boolean;
      skills: boolean;
    }
    ```

    Keep existing types (ErrorContext, ExclusionResult, SyncConfig) intact.

    **2. Create `src/secrets/env-loader.ts`:**

    - `loadSecrets(envPath: string): { secrets: Record<string, string>; warnings: string[] }`
    - Parse KEY=VALUE lines from file at `envPath`
    - Handle: quoted values (single/double), comments (#), blank lines, export prefix
    - If file doesn't exist: return empty secrets + warning "No .env file found at {path}" (per user decision: warn, don't throw)
    - Use `Bun.file(envPath).exists()` to check, `Bun.file(envPath).text()` to read
    - No variable expansion (our .env files are simple)

    **3. Create `src/secrets/injector.ts`:**

    - `injectSecrets(content: string, secrets: Record<string, string>): { result: string; warnings: string[] }`
    - Replace `${VAR_NAME}` with value from secrets map
    - If VAR_NAME not in secrets: leave `${VAR_NAME}` intact, add warning "Unresolved secret: VAR_NAME" (per user decision)
    - `redactSecrets(content: string, secrets: Record<string, string>): string`
    - Replace actual secret values in content with `****` (per user decision: show `****`, not placeholder names)
    - Sort secrets by length descending before replacing (avoid partial matches)

    **4. Create `src/secrets/env-var-transformer.ts`:**

    Port from vsync `utils/env-var-transformer.ts` as a class (per user decision: keep instance method pattern).

    ```typescript
    export type EnvVarFormat = 'claude-code' | 'opencode' | 'gemini' | 'codex';

    export class EnvVarTransformer {
      static transform(value: unknown, from: EnvVarFormat, to: EnvVarFormat): unknown;
      static toOpenCode(value: unknown): unknown;   // claude-code → opencode
      static fromOpenCode(value: unknown): unknown;  // opencode → claude-code
      // Private: transformString, toNormalized, fromNormalized
    }
    ```

    - Normalize through claude-code format (`${VAR}`) as intermediate
    - `opencode` format: `{env:VAR_NAME}` (curly braces, no dollar)
    - `gemini` format: same as `claude-code` (`${VAR}`)
    - `codex` format: env vars referenced by name only in arrays, not as `${VAR}` strings — handle this by stripping `${}` wrapper, returning bare var name
    - Recursive: handle strings, arrays, objects
    - Remove "cursor" format from vsync original, add "gemini" + "codex"

    **5. Create tests** in `src/secrets/__tests__/`:

    - `env-loader.test.ts`: file exists with various formats (quoted, comments, export prefix, blank lines), file missing returns empty + warning, malformed lines skipped
    - `injector.test.ts`: successful injection, partial injection with warnings, no secrets (all unresolved), redaction replaces values with `****`, redaction handles overlapping values
    - `env-var-transformer.test.ts`: claude→opencode, opencode→claude, identity transform, recursive object/array, gemini→opencode, codex format handling

    **6. Add `SecretError`** to `src/errors.ts`:

    ```typescript
    export class SecretError extends SyncError {
      constructor(message: string, context: ErrorContext) {
        super(message, ErrorSeverity.WARNING, { operation: context.operation, path: context.path });
        this.name = 'SecretError';
        this.operation = context.operation;
        this.path = context.path;
        this.cause = context.cause;
      }
    }
    ```
  </action>
  <verify>
    Run `bun test src/secrets/` — all tests pass.
    Verify exports: `bun -e "import { loadSecrets } from './src/secrets/env-loader'; import { EnvVarTransformer } from './src/secrets/env-var-transformer'; console.log('OK')"` succeeds.
  </verify>
  <done>
    - loadSecrets reads .env files and returns secrets map + warnings for missing file
    - injectSecrets replaces ${VAR} placeholders, warns on unresolved
    - redactSecrets replaces values with ****
    - EnvVarTransformer converts between all 4 target formats
    - types.ts has CanonicalItem, MCPServer, RenderedFile, AdapterCapabilities, TargetName
    - All secrets tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: BaseAdapter, ToolAdapter interface, and PathResolver</name>
  <files>
    src/adapters/base.ts
    src/adapters/path-resolver.ts
  </files>
  <action>
    **1. Create `src/adapters/path-resolver.ts`:**

    Port from vsync, simplified for our 4 fixed targets. Centralizes all target path construction.

    ```typescript
    export class AdapterPathResolver {
      constructor(private readonly target: TargetName) {}

      // Base config directories per target
      getBaseDir(): string;          // e.g., ~/.claude, ~/.config/opencode, ~/.gemini, ~/.codex
      getCommandsDir(): string;      // e.g., ~/.claude/commands/zz/, ~/.config/opencode/command/
      getAgentsDir(): string;        // e.g., ~/.claude/agents/, ~/.config/opencode/agents/
      getMCPConfigPath(): string;    // e.g., ~/.claude/settings.json
      getInstructionsPath(): string; // e.g., ~/.claude/CLAUDE.md
      getSkillsDir(): string;        // e.g., ~/.config/opencode/skill/

      // Expand ~ to homedir
      expandHome(p: string): string;

      // Full path for a rendered command file
      getCommandFilePath(name: string): string;
      // Full path for a rendered agent file
      getAgentFilePath(name: string): string;
    }
    ```

    Target paths (from AGENTS.md + research):
    - **claude-code**: base=`~/.claude`, commands=`~/.claude/commands/zz/`, agents=`~/.claude/agents/`, mcp=`~/.claude/settings.json`, instructions=`~/.claude/CLAUDE.md`
    - **opencode**: base=`~/.config/opencode`, commands=`~/.config/opencode/command/`, agents=`~/.config/opencode/agents/`, mcp=`~/.config/opencode/opencode.jsonc` (or settings file), instructions=`~/.config/opencode/OPENCODE.md`, skills=`~/.config/opencode/skill/`
    - **gemini**: base=`~/.gemini`, commands=`~/.gemini/commands/`, agents=`~/.gemini/agents/`, mcp=`~/.gemini/settings.json`, instructions=`~/.gemini/GEMINI.md`
    - **codex**: base=`~/.codex`, commands=`~/.codex/prompts/`, agents=`~/.codex/prompts/` (agent- prefix), mcp=`~/.codex/config.toml`, instructions=`~/.codex/instructions.md`

    Use `os.homedir()` + `path.join()` for `~` expansion. All paths fully expanded (per user decision: output is write-ready).

    Claude command name: strip `zz-` prefix → nest under `zz/` subdir (e.g., `zz-plan` → `zz/plan.md`).
    Gemini command extension: `.md` → `.toml`.
    Other targets: keep filename as-is.

    **2. Create `src/adapters/base.ts`:**

    Port from vsync BaseAdapter, render-only (per user decision: bring over class hierarchy, exclude I/O).

    ```typescript
    export interface ToolAdapter {
      readonly target: TargetName;
      readonly displayName: string;

      getCapabilities(): AdapterCapabilities;

      // Render single items — return content + relative path
      renderCommand(item: CanonicalItem): RenderedFile;
      renderAgent(item: CanonicalItem): RenderedFile;

      // Render all MCP servers → complete settings content
      renderMCPServers(servers: MCPServer[], existingContent?: string): string;

      // Render instructions — concat base + addendum
      renderInstructions(baseMd: string, addendumMd: string): string;
    }

    export abstract class BaseAdapter implements ToolAdapter {
      readonly target: TargetName;
      readonly displayName: string;
      protected readonly paths: AdapterPathResolver;

      constructor(target: TargetName, displayName: string) {
        this.target = target;
        this.displayName = displayName;
        this.paths = new AdapterPathResolver(target);
      }

      abstract getCapabilities(): AdapterCapabilities;
      abstract renderCommand(item: CanonicalItem): RenderedFile;
      abstract renderAgent(item: CanonicalItem): RenderedFile;
      abstract renderMCPServers(servers: MCPServer[], existingContent?: string): string;

      // Default: concatenate base + addendum with double newline separator
      renderInstructions(baseMd: string, addendumMd: string): string {
        return baseMd + '\n\n' + addendumMd + '\n';
      }

      // Helper: expand ~ in content strings
      protected expandPaths(content: string): string {
        return content.replace(/~\//g, os.homedir() + '/');
      }
    }
    ```

    No tests for base.ts — it's abstract. Tests come with concrete adapters in Plan 02.
  </action>
  <verify>
    TypeScript compiles: `bun build src/adapters/base.ts --no-bundle` succeeds (or `bun -e "import { BaseAdapter } from './src/adapters/base'; console.log('OK')"` — will fail at runtime since abstract, but type-check should pass).
    Verify PathResolver: `bun -e "import { AdapterPathResolver } from './src/adapters/path-resolver'; const p = new AdapterPathResolver('claude-code'); console.log(p.getCommandsDir())"` outputs path with expanded homedir.
  </verify>
  <done>
    - ToolAdapter interface defines render contract (renderCommand, renderAgent, renderMCPServers, renderInstructions)
    - BaseAdapter abstract class provides constructor, PathResolver integration, expandPaths helper
    - AdapterPathResolver resolves all target-specific paths for all 4 CLIs
    - Claude command naming convention (strip zz- prefix, nest zz/ subdir) handled in PathResolver
    - All paths use expanded homedir (no ~ in output)
  </done>
</task>

</tasks>

<verification>
- `bun test src/secrets/` — all secret tests pass
- Types compile: `bun -e "import type { CanonicalItem, MCPServer, RenderedFile, TargetName } from './src/types'"` succeeds
- PathResolver resolves correct paths for each target
- EnvVarTransformer converts between all format pairs correctly
</verification>

<success_criteria>
- Secret loading, injection, redaction, and env var format conversion all work
- BaseAdapter/ToolAdapter interface establishes render contract for Plan 02
- PathResolver knows where each target's files live
- No I/O in adapters — pure render functions returning strings
- All 17+ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-renderers-secrets/02-01-SUMMARY.md`
</output>
