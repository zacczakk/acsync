---
phase: 02-renderers-secrets
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/adapters/claude-code.ts
  - src/adapters/opencode.ts
  - src/adapters/gemini.ts
  - src/adapters/codex.ts
  - src/adapters/__tests__/claude-code.test.ts
  - src/adapters/__tests__/opencode.test.ts
  - src/adapters/__tests__/gemini.test.ts
  - src/adapters/__tests__/codex.test.ts
autonomous: true
requirements: [RNDR-01, RNDR-02, RNDR-03, RNDR-04, RNDR-05, RNDR-06, RNDR-07, RNDR-08]

must_haves:
  truths:
    - "Canonical command renders correctly to all 4 target formats"
    - "Canonical agent renders correctly to all 4 target formats"
    - "Claude commands strip zz- prefix and body is verbatim with all frontmatter keys preserved"
    - "OpenCode commands strip allowed-tools from frontmatter"
    - "OpenCode agents add mode: subagent and strip name + allowed-tools"
    - "Gemini commands output TOML with triple-quoted prompt and {args} appended"
    - "Gemini agents add kind: local to frontmatter"
    - "Codex commands use # /{name} heading with description paragraph"
    - "Codex agents use # Agent: {name} heading with **Role** and **Allowed Tools** lines"
  artifacts:
    - path: "src/adapters/claude-code.ts"
      provides: "ClaudeCodeAdapter — renderCommand + renderAgent"
      exports: ["ClaudeCodeAdapter"]
    - path: "src/adapters/opencode.ts"
      provides: "OpenCodeAdapter — renderCommand + renderAgent"
      exports: ["OpenCodeAdapter"]
    - path: "src/adapters/gemini.ts"
      provides: "GeminiAdapter — renderCommand + renderAgent"
      exports: ["GeminiAdapter"]
    - path: "src/adapters/codex.ts"
      provides: "CodexAdapter — renderCommand + renderAgent"
      exports: ["CodexAdapter"]
  key_links:
    - from: "src/adapters/claude-code.ts"
      to: "src/adapters/base.ts"
      via: "extends BaseAdapter"
      pattern: "extends BaseAdapter"
    - from: "src/adapters/opencode.ts"
      to: "src/formats/markdown.ts"
      via: "uses stringifyFrontmatter for rebuilt frontmatter"
      pattern: "stringifyFrontmatter"
    - from: "src/adapters/gemini.ts"
      to: "src/formats/toml.ts"
      via: "uses writeToml for TOML output"
      pattern: "writeToml"
---

<objective>
Command and agent renderers for all 4 target CLIs (8 render functions total).

Purpose: Each adapter class gets its `renderCommand()` and `renderAgent()` methods, producing correctly formatted output per target. This is the core rendering — transforming canonical markdown configs into CLI-specific formats.

Output: 4 adapter classes (claude-code, opencode, gemini, codex) with command + agent rendering + tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-renderers-secrets/02-RESEARCH.md
@.planning/phases/02-renderers-secrets/02-CONTEXT.md
@.planning/phases/02-renderers-secrets/02-01-SUMMARY.md
@src/types.ts
@src/adapters/base.ts
@src/adapters/path-resolver.ts
@src/formats/markdown.ts
@src/formats/toml.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Claude Code + OpenCode adapters (commands + agents)</name>
  <files>
    src/adapters/claude-code.ts
    src/adapters/opencode.ts
    src/adapters/__tests__/claude-code.test.ts
    src/adapters/__tests__/opencode.test.ts
  </files>
  <action>
    **1. Create `src/adapters/claude-code.ts`:**

    ```typescript
    export class ClaudeCodeAdapter extends BaseAdapter {
      constructor() { super('claude-code', 'Claude Code'); }

      getCapabilities(): AdapterCapabilities {
        return { commands: true, agents: true, mcp: true, instructions: true, skills: true };
      }

      renderCommand(item: CanonicalItem): RenderedFile {
        // Claude Code commands: body verbatim, all frontmatter preserved
        // Path: strip zz- prefix, nest under zz/ (handled by PathResolver)
        const content = stringifyFrontmatter(item.content, item.metadata);
        return {
          relativePath: this.paths.getCommandFilePath(item.name),
          content,
        };
      }

      renderAgent(item: CanonicalItem): RenderedFile {
        // Claude Code agents: body verbatim, frontmatter preserved
        // Path: nest under zz/ subdir (if applicable)
        const content = stringifyFrontmatter(item.content, item.metadata);
        return {
          relativePath: this.paths.getAgentFilePath(item.name),
          content,
        };
      }

      // renderMCPServers — stub for now, implemented in Plan 03
      renderMCPServers(servers: MCPServer[], existingContent?: string): string {
        throw new Error('Not implemented — see Plan 03');
      }
    }
    ```

    Key details per CONTEXT.md decisions:
    - Claude commands: ALL frontmatter keys pass through (description, argument-hint, allowed-tools)
    - Claude agents: ALL frontmatter keys pass through (name, description, allowed-tools)
    - Content is body verbatim — no modifications
    - Path naming handled by PathResolver (zz- prefix stripping + zz/ nesting)

    **2. Create `src/adapters/opencode.ts`:**

    ```typescript
    export class OpenCodeAdapter extends BaseAdapter {
      constructor() { super('opencode', 'OpenCode'); }

      getCapabilities(): AdapterCapabilities {
        return { commands: true, agents: true, mcp: true, instructions: true, skills: true };
      }

      renderCommand(item: CanonicalItem): RenderedFile {
        // OpenCode commands: rebuild frontmatter, strip allowed-tools and argument-hint
        // Keep: description (and any other OpenCode-relevant keys)
        const metadata: Record<string, unknown> = {};
        if (item.metadata.description) metadata.description = item.metadata.description;
        // Strip: allowed-tools, argument-hint (per research: OpenCode commands don't use these)

        const content = stringifyFrontmatter(item.content, metadata);
        return {
          relativePath: this.paths.getCommandFilePath(item.name),
          content,
        };
      }

      renderAgent(item: CanonicalItem): RenderedFile {
        // OpenCode agents: strip name + allowed-tools, add mode: subagent
        const metadata: Record<string, unknown> = {};
        if (item.metadata.description) metadata.description = item.metadata.description;
        metadata.mode = 'subagent';
        // Strip: name (redundant with filename), allowed-tools

        const content = stringifyFrontmatter(item.content, metadata);
        return {
          relativePath: this.paths.getAgentFilePath(item.name),
          content,
        };
      }

      // renderMCPServers — stub for Plan 03
      renderMCPServers(servers: MCPServer[], existingContent?: string): string {
        throw new Error('Not implemented — see Plan 03');
      }
    }
    ```

    Key details:
    - Commands: only `description` in frontmatter, everything else stripped
    - Agents: `description` + `mode: subagent`, strip `name` and `allowed-tools`
    - Use `stringifyFrontmatter` from Phase 1 for consistent output
    - Keep `zz-` prefix in filenames (OpenCode convention)

    **3. Create tests** in `src/adapters/__tests__/`:

    - `claude-code.test.ts`:
      - renderCommand: produces correct relativePath (zz/ nesting), preserves all frontmatter, body verbatim
      - renderAgent: produces correct path, preserves frontmatter
      - Test with real canonical input shape (name, content, metadata with description/allowed-tools/argument-hint)

    - `opencode.test.ts`:
      - renderCommand: strips allowed-tools and argument-hint, keeps description only
      - renderAgent: adds mode:subagent, strips name and allowed-tools
      - Verify frontmatter contains only expected keys (no extras leaking through)
  </action>
  <verify>
    Run `bun test src/adapters/__tests__/claude-code.test.ts src/adapters/__tests__/opencode.test.ts` — all pass.
  </verify>
  <done>
    - ClaudeCodeAdapter.renderCommand preserves all frontmatter + body verbatim with zz/ nested path
    - ClaudeCodeAdapter.renderAgent preserves all frontmatter + body
    - OpenCodeAdapter.renderCommand keeps description only, strips allowed-tools/argument-hint
    - OpenCodeAdapter.renderAgent adds mode:subagent, strips name/allowed-tools
    - 8+ tests verify correct output format
  </done>
</task>

<task type="auto">
  <name>Task 2: Gemini + Codex adapters (commands + agents)</name>
  <files>
    src/adapters/gemini.ts
    src/adapters/codex.ts
    src/adapters/__tests__/gemini.test.ts
    src/adapters/__tests__/codex.test.ts
  </files>
  <action>
    **1. Create `src/adapters/gemini.ts`:**

    ```typescript
    export class GeminiAdapter extends BaseAdapter {
      constructor() { super('gemini', 'Gemini'); }

      getCapabilities(): AdapterCapabilities {
        return { commands: true, agents: true, mcp: true, instructions: true, skills: false };
      }

      renderCommand(item: CanonicalItem): RenderedFile {
        // Gemini commands: TOML format, not markdown
        // description as top-level key, body as prompt = """..."""
        // Strip allowed-tools, argument-hint from output
        // Append "User arguments: {args}" at end of prompt (always)
        const body = item.content.trim();
        const prompt = body + '\n\nUser arguments: {args}';

        // Build TOML manually for triple-quoted string support
        // smol-toml stringify doesn't produce triple-quoted strings well
        const description = String(item.metadata.description ?? '');
        const tomlContent = `description = ${JSON.stringify(description)}\nprompt = """\n${prompt}\n"""\n`;

        return {
          relativePath: this.paths.getCommandFilePath(item.name),  // .toml extension
          content: tomlContent,
        };
      }

      renderAgent(item: CanonicalItem): RenderedFile {
        // Gemini agents: markdown with frontmatter, add kind: local
        const metadata: Record<string, unknown> = {};
        if (item.metadata.description) metadata.description = item.metadata.description;
        if (item.metadata['allowed-tools']) metadata['allowed-tools'] = item.metadata['allowed-tools'];
        metadata.kind = 'local';

        const content = stringifyFrontmatter(item.content, metadata);
        return {
          relativePath: this.paths.getAgentFilePath(item.name),
          content,
        };
      }

      // renderMCPServers — stub for Plan 03
      renderMCPServers(servers: MCPServer[], existingContent?: string): string {
        throw new Error('Not implemented — see Plan 03');
      }
    }
    ```

    Key details:
    - Commands output `.toml` files (PathResolver handles extension change)
    - `prompt = """..."""` uses TOML multi-line basic string with triple quotes
    - Always append `User arguments: {args}` at end of prompt (per research)
    - Strip `allowed-tools` and `argument-hint` from TOML output
    - Agents: keep `description` + `allowed-tools`, add `kind: local`

    **2. Create `src/adapters/codex.ts`:**

    ```typescript
    export class CodexAdapter extends BaseAdapter {
      constructor() { super('codex', 'Codex'); }

      getCapabilities(): AdapterCapabilities {
        return { commands: true, agents: true, mcp: true, instructions: true, skills: false };
      }

      renderCommand(item: CanonicalItem): RenderedFile {
        // Codex commands: flat markdown, no frontmatter
        // # /{name} heading, description paragraph, then body
        const description = String(item.metadata.description ?? '');
        const body = item.content.trim();
        const content = `# /${item.name}\n\n${description}\n\n${body}\n`;

        return {
          relativePath: this.paths.getCommandFilePath(item.name),
          content,
        };
      }

      renderAgent(item: CanonicalItem): RenderedFile {
        // Codex agents: flat markdown
        // # Agent: {name} heading
        // **Role**: description
        // **Allowed Tools**: tool1, tool2
        // Then body
        const description = String(item.metadata.description ?? '');
        const tools = item.metadata['allowed-tools'];
        const toolsLine = Array.isArray(tools) ? tools.join(', ') : String(tools ?? '');
        const body = item.content.trim();

        let content = `# Agent: ${item.name}\n\n**Role**: ${description}\n\n`;
        if (toolsLine) {
          content += `**Allowed Tools**: ${toolsLine}\n\n`;
        }
        content += `${body}\n`;

        return {
          relativePath: this.paths.getAgentFilePath(item.name),
          content,
        };
      }

      // renderMCPServers — stub for Plan 03
      renderMCPServers(servers: MCPServer[], existingContent?: string): string {
        throw new Error('Not implemented — see Plan 03');
      }
    }
    ```

    Key details (per user decision: implement ALL Codex renderers, trust prior patterns):
    - Commands: `# /{name}` heading + description paragraph + body. No frontmatter.
    - Agents: `# Agent: {name}` heading + `**Role**` + `**Allowed Tools**` + body. No frontmatter.
    - Codex commands and agents both go to `~/.codex/prompts/` (agents prefixed with `agent-`)

    **3. Create tests:**

    - `gemini.test.ts`:
      - renderCommand: outputs valid TOML with `description` and `prompt = """..."""`, includes `{args}` at end
      - renderCommand: no allowed-tools or argument-hint in output
      - renderAgent: adds `kind: local` to frontmatter, keeps description + allowed-tools

    - `codex.test.ts`:
      - renderCommand: `# /{name}` heading, description paragraph, body follows
      - renderAgent: `# Agent: {name}` heading, **Role** line, **Allowed Tools** line, body
      - renderAgent: omits **Allowed Tools** line when not present in canonical
  </action>
  <verify>
    Run `bun test src/adapters/__tests__/gemini.test.ts src/adapters/__tests__/codex.test.ts` — all pass.
    Run `bun test src/adapters/` — all adapter tests pass together.
  </verify>
  <done>
    - GeminiAdapter.renderCommand produces TOML with triple-quoted prompt + {args}
    - GeminiAdapter.renderAgent adds kind:local to frontmatter
    - CodexAdapter.renderCommand produces flat markdown with # /{name} heading
    - CodexAdapter.renderAgent produces flat markdown with # Agent: heading + Role/Tools lines
    - All 4 adapter classes extend BaseAdapter and implement ToolAdapter interface
    - 8+ tests verify all format conversions
  </done>
</task>

</tasks>

<verification>
- `bun test src/adapters/` — all adapter tests pass
- Each adapter produces correctly formatted output matching research examples
- Claude preserves all frontmatter, OpenCode strips extras, Gemini outputs TOML, Codex outputs flat markdown
- No I/O in any adapter — pure string rendering
</verification>

<success_criteria>
- 8 render functions work (4 targets × 2 types = commands + agents)
- Output matches format examples from research (Claude=verbatim, OpenCode=rebuilt frontmatter, Gemini=TOML, Codex=flat markdown)
- All adapters extend BaseAdapter and compile cleanly
- Tests verify each format transformation
</success_criteria>

<output>
After completion, create `.planning/phases/02-renderers-secrets/02-02-SUMMARY.md`
</output>
