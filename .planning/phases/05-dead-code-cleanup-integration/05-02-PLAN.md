---
phase: 05-dead-code-cleanup-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/cli/orchestrator.ts
  - src/cli/canonical.ts
  - src/cli/sync-check.ts
  - src/cli/sync-push.ts
  - src/cli/sync-pull.ts
  - src/cli/check.ts
  - src/cli/push.ts
  - src/cli/pull.ts
  - src/cli/diff.ts
  - src/cli/render.ts
  - src/cli/__tests__/orchestrator.test.ts
autonomous: true
requirements: [HYGIENE-SPLIT, HYGIENE-PULL-SAFETY]

must_haves:
  truths:
    - "orchestrator.ts is either deleted or a thin re-export facade"
    - "Each split module is under 500 LOC"
    - "Pull uses atomicWrite for crash-safe canonical file writes"
    - "Pull has restore-on-failure rollback like push"
    - "All tests pass after split"
  artifacts:
    - path: "src/cli/canonical.ts"
      provides: "Canonical config readers + adapter factory"
      exports: ["readCanonicalCommands", "readCanonicalAgents", "readCanonicalMCPServers", "readCanonicalInstructions", "readCanonicalSkills", "createAdapter", "ALL_TARGETS"]
    - path: "src/cli/sync-check.ts"
      provides: "runCheck operation"
      exports: ["runCheck"]
    - path: "src/cli/sync-push.ts"
      provides: "runPush operation"
      exports: ["runPush"]
    - path: "src/cli/sync-pull.ts"
      provides: "runPull and runPullAll operations"
      exports: ["runPull", "runPullAll"]
  key_links:
    - from: "src/cli/sync-push.ts"
      to: "src/cli/canonical.ts"
      via: "imports readers and adapter factory"
      pattern: "import.*from.*canonical"
    - from: "src/cli/sync-pull.ts"
      to: "src/infra/atomic-write.ts"
      via: "atomicWrite for crash-safe writes"
      pattern: "import.*atomicWrite"
    - from: "src/cli/sync-pull.ts"
      to: "src/core/rollback.ts"
      via: "createBackup/restoreAll for rollback"
      pattern: "import.*createBackup.*restoreAll"
---

<objective>
Wire atomicWrite + rollback into pull and split orchestrator.ts into modules under 500 LOC.

Purpose: Pull gets same crash-safety as push (restore-on-failure). Orchestrator split keeps each module maintainable. Per CONTEXT.md: operation-named sibling files in src/cli/.
Output: 4 focused modules replacing 1028-line orchestrator.ts, pull with rollback safety.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dead-code-cleanup-integration/05-01-SUMMARY.md
@src/cli/orchestrator.ts
@src/cli/check.ts
@src/cli/push.ts
@src/cli/pull.ts
@src/cli/diff.ts
@src/cli/render.ts
@src/core/rollback.ts
@src/infra/atomic-write.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire atomicWrite + rollback into pull</name>
  <files>
    src/cli/orchestrator.ts
  </files>
  <action>
    **Per CONTEXT.md:** Pull gets full rollback like push (restore-on-failure across all canonical files).

    In `runPull` function:
    1. Import `atomicWrite` from `../infra/atomic-write` and `createBackup`, `restoreAll`, `cleanupAll` from `../core/rollback`
    2. Replace all `Bun.write(targetPath, output)` calls with the rollback pattern:
       - Before writing: `const backup = await createBackup(targetPath); allBackups.push(backup);`
       - Write: `await atomicWrite(targetPath, output)` (no backupDir — Plan 01 removed it)
       - On catch: `await restoreAll(allBackups); rolledBack = true;`
       - On success: `await cleanupAll(allBackups);`
    3. Same pattern for skill SKILL.md writes and supportFiles writes
    4. Track `allBackups: BackupInfo[]` across all items in the pull
    5. Add `rolledBack: boolean` to `OrchestratorPullResult` interface

    In `runPullAll`:
    - The per-target `runPull` calls already handle their own rollback internally
    - No additional rollback needed at the pullAll level (each target is independent)

    Do NOT change the pull CLI command (src/cli/pull.ts) — it already has confirmation flow. The rollback is in the orchestrator layer.
  </action>
  <verify>
    `bun test` passes. Verify `grep 'Bun.write' src/cli/orchestrator.ts` returns no matches (all writes use atomicWrite now).
  </verify>
  <done>
    runPull uses atomicWrite for all canonical file writes. Rollback restores all files on first error. OrchestratorPullResult includes rolledBack field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Split orchestrator.ts into operation-named modules</name>
  <files>
    src/cli/canonical.ts
    src/cli/sync-check.ts
    src/cli/sync-push.ts
    src/cli/sync-pull.ts
    src/cli/orchestrator.ts
    src/cli/check.ts
    src/cli/push.ts
    src/cli/pull.ts
    src/cli/diff.ts
    src/cli/render.ts
    src/cli/__tests__/orchestrator.test.ts
  </files>
  <action>
    Split orchestrator.ts into 4 modules. Per CONTEXT.md: flat sibling files in src/cli/, operation-named.

    **src/cli/canonical.ts** (~150 LOC) — shared infrastructure:
    - Move: `createAdapter`, `ALL_TARGETS`, `hashContent`, `hashRendered`, `hashTargetFile`
    - Move: `readCanonicalCommands`, `readCanonicalAgents`, `readCanonicalMCPServers`, `readCanonicalInstructions`, `readCanonicalSkills`
    - Move: `SyncOptions` interface (shared by check and push)
    - All imports these functions need (readdir, readFile, join, basename, createHash, parseFrontmatter, readSupportFiles, adapter constructors, types)
    - Export everything that other modules import

    **src/cli/sync-check.ts** (~200 LOC) — check operation:
    - Move: `runCheck`, `detectStaleItems`, `OrchestratorCheckResult` interface
    - Import from canonical.ts: createAdapter, ALL_TARGETS, hashRendered, hashTargetFile, readCanonical*, SyncOptions
    - Import from core: loadManifest, calculateDiff, formatCheckResult
    - Import from infra: createExclusionFilter, classifyEntry

    **src/cli/sync-push.ts** (~200 LOC) — push operation:
    - Move: `runPush`, `OrchestratorPushResult` interface
    - Import from canonical.ts: createAdapter, readCanonical*, SyncOptions, hashContent
    - Import from sync-check.ts: runCheck
    - Import from core: loadManifest, saveManifest, updateManifestItem, createBackup, restoreAll, cleanupAll, formatDryRunResult, formatPushResult

    **src/cli/sync-pull.ts** (~300 LOC) — pull operation:
    - Move: `runPull`, `runPullAll`, `PullOptions`, `PullItem`, `OrchestratorPullResult`, `PullAllOptions` interfaces
    - Move: `formatPullResult`, `formatPullAllResult`, `displayTarget` private functions
    - Import from canonical.ts: createAdapter, ALL_TARGETS
    - Import from core: createBackup, restoreAll, cleanupAll (wired in Task 1)
    - Import from infra: atomicWrite

    **src/cli/orchestrator.ts** — convert to re-export facade:
    - Re-export everything from canonical.ts, sync-check.ts, sync-push.ts, sync-pull.ts
    - This preserves backward compatibility for existing imports (`import { runCheck } from './orchestrator'`)
    - Should be ~15 lines (just re-exports)

    **Update existing CLI commands** (check.ts, push.ts, pull.ts, diff.ts, render.ts):
    - Update imports from `'./orchestrator'` to the specific module for clarity
    - e.g., `import { runCheck } from './sync-check'` instead of `'./orchestrator'`
    - This is optional if the facade re-exports work, but preferred for clean dependencies

    **Update tests:**
    - If `src/cli/__tests__/orchestrator.test.ts` exists, update imports to match new module locations
    - If it doesn't exist, no action needed (the integration tests likely import from the CLI commands)

    **Verify each resulting file is <500 LOC:**
    - canonical.ts: ~150 LOC
    - sync-check.ts: ~200 LOC
    - sync-push.ts: ~200 LOC
    - sync-pull.ts: ~300 LOC
    - orchestrator.ts (facade): ~15 LOC
  </action>
  <verify>
    `bun test` — all 448+ tests pass. `wc -l src/cli/canonical.ts src/cli/sync-check.ts src/cli/sync-push.ts src/cli/sync-pull.ts src/cli/orchestrator.ts` — each under 500. `grep -r "from './orchestrator'" src/cli/*.ts` — only facade re-exports or updated to specific modules.
  </verify>
  <done>
    orchestrator.ts split into canonical.ts, sync-check.ts, sync-push.ts, sync-pull.ts. Each module <500 LOC. Re-export facade preserves backward compatibility. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `bun test` — 0 failures
2. `wc -l src/cli/canonical.ts src/cli/sync-check.ts src/cli/sync-push.ts src/cli/sync-pull.ts` — each under 500
3. `wc -l src/cli/orchestrator.ts` — under 20 (facade only)
4. `grep 'Bun.write' src/cli/sync-pull.ts` — no matches (all writes use atomicWrite)
5. `grep -rn 'createBackup\|restoreAll' src/cli/sync-pull.ts` — has matches (rollback wired in)
</verification>

<success_criteria>
- Pull uses atomicWrite + rollback (same crash-safety as push)
- orchestrator.ts is a thin re-export facade (~15 LOC)
- Each split module under 500 LOC
- All existing tests pass with 0 failures
- No broken imports anywhere
</success_criteria>

<output>
After completion, create `.planning/phases/05-dead-code-cleanup-integration/05-02-SUMMARY.md`
</output>
