---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/formats/json.ts
  - src/formats/jsonc.ts
  - src/formats/toml.ts
  - src/formats/markdown.ts
  - src/formats/__tests__/json.test.ts
  - src/formats/__tests__/jsonc.test.ts
  - src/formats/__tests__/toml.test.ts
  - src/formats/__tests__/markdown.test.ts
  - package.json
autonomous: true
requirements:
  - DIFF-01
  - FILE-01

must_haves:
  truths:
    - "JSON files parse and stringify with consistent formatting"
    - "JSONC files preserve comments through read-modify-write cycles"
    - "TOML files parse to objects and stringify back correctly"
    - "Markdown frontmatter round-trips (parse → modify → stringify preserves content)"
  artifacts:
    - path: "src/formats/json.ts"
      provides: "Plain JSON read/write"
      exports: ["readJson", "writeJson"]
    - path: "src/formats/jsonc.ts"
      provides: "JSONC read/modify/write with comment preservation"
      exports: ["readJsonc", "modifyJsonc"]
    - path: "src/formats/toml.ts"
      provides: "TOML parse/stringify"
      exports: ["readToml", "writeToml"]
    - path: "src/formats/markdown.ts"
      provides: "Markdown frontmatter parse/stringify"
      exports: ["parseFrontmatter", "stringifyFrontmatter"]
  key_links:
    - from: "src/formats/jsonc.ts"
      to: "jsonc-parser"
      via: "import { parse, modify, applyEdits }"
      pattern: "jsonc-parser"
    - from: "src/formats/toml.ts"
      to: "smol-toml"
      via: "import { parse, stringify }"
      pattern: "smol-toml"
    - from: "src/formats/markdown.ts"
      to: "gray-matter"
      via: "import matter from 'gray-matter'"
      pattern: "gray-matter"
    - from: "src/formats/*.ts"
      to: "src/errors.ts"
      via: "wraps parse/stringify errors in ParseError"
      pattern: "ParseError"
---

<objective>
Build format parsers for all config file types: JSON, JSONC (with comment preservation), TOML, and Markdown frontmatter. Each parser must round-trip cleanly.

Purpose: Phase 2 renderers transform canonical configs into CLI-specific formats. These parsers are the read/write primitives that make that possible. JSONC comment preservation is critical — user-edited config files must not lose comments during sync.

Output: 4 format parser modules + 4 test files + 3 new dependencies installed.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install deps and create JSON + JSONC parsers</name>
  <files>
    package.json
    src/formats/json.ts
    src/formats/jsonc.ts
    src/formats/__tests__/json.test.ts
    src/formats/__tests__/jsonc.test.ts
  </files>
  <action>
Install Phase 1 format parser dependencies and create JSON/JSONC modules.

**vsync reference files (read before implementing):**
- `~/Repos/oss/vsync/cli/src/utils/file-ops.ts` — vsync's `readJSONC`/`writeJSONC` functions use the exact same `jsonc-parser` `modify()`+`applyEdits()` pattern we need. Study lines 82-115 for the JSONC approach. vsync combines format parsing + file I/O + atomicWrite in one module; we intentionally split them (pure parse in `formats/`, I/O in `infra/`) for better separation of concerns. Our format parsers operate on strings, not files.
- `~/Repos/oss/vsync/cli/src/utils/file-ops.ts` lines 120-143 — vsync's `readTOML`/`writeTOML` use `@iarna/toml`; we use `smol-toml` instead (newer, TOML 1.1 compliant, smaller — per research).

**Install dependencies:**
```bash
bun add jsonc-parser@^3.3 smol-toml@^1.6 gray-matter@^4
```

**src/formats/json.ts** — Plain JSON read/write:
- `readJson<T = unknown>(raw: string): T` — `JSON.parse(raw)`, wraps errors in `ParseError` with `{ operation: 'readJson', path: '<string input>' }`
- `writeJson(data: unknown, indent?: number): string` — `JSON.stringify(data, null, indent ?? 2) + '\n'`, wraps errors in `ParseError`
- These are thin wrappers that add consistent error handling. The value is the error contract, not the parsing itself.

**src/formats/jsonc.ts** — JSONC with comment preservation (same `jsonc-parser` API as vsync's `writeJSONC`):
- `readJsonc<T = unknown>(raw: string): T` — uses `parse()` from `jsonc-parser` (NOT `JSON.parse` — that strips comments silently). Wraps errors in `ParseError`.
- `modifyJsonc(existingText: string, path: (string | number)[], value: unknown): string` — uses `modify()` + `applyEdits()` from `jsonc-parser` (identical pattern to vsync's `writeJSONC` at file-ops.ts:107-110). Formatting options: `{ tabSize: 2, insertSpaces: true, eol: '\n' }`. Returns the modified JSONC string with all comments preserved outside the edit path. Wraps errors in `ParseError`.
- Import `{ parse, modify, applyEdits, type FormattingOptions }` from `jsonc-parser`
- CRITICAL: Never use `JSON.parse` on JSONC content. The `parse` from `jsonc-parser` handles comments and trailing commas.

**Tests (src/formats/__tests__/json.test.ts):**
- readJson parses valid JSON
- readJson throws ParseError on invalid JSON
- writeJson produces indented JSON with trailing newline
- writeJson → readJson round-trip preserves data

**Tests (src/formats/__tests__/jsonc.test.ts):**
- readJsonc parses JSONC with comments
- readJsonc parses JSONC with trailing commas
- readJsonc throws ParseError on malformed input
- modifyJsonc preserves comments when modifying a value
- modifyJsonc preserves comments when adding a new key
- modifyJsonc works on nested paths (e.g., `['mcpServers', 'tavily']`)
- Round-trip: readJsonc(modifyJsonc(original, path, value)) reflects the change while preserving surrounding comments

Follow codebase conventions: camelCase functions, PascalCase types, 2-space indent, single quotes.
  </action>
  <verify>
    `bun test src/formats/__tests__/json.test.ts src/formats/__tests__/jsonc.test.ts` — all tests pass
  </verify>
  <done>
    - jsonc-parser, smol-toml, gray-matter installed in package.json
    - readJson/writeJson round-trip cleanly with consistent error handling
    - readJsonc parses JSONC with comments and trailing commas
    - modifyJsonc edits values while preserving all comments outside edit path
    - All errors wrapped in ParseError with operation context
  </done>
</task>

<task type="auto">
  <name>Task 2: TOML and Markdown frontmatter parsers</name>
  <files>
    src/formats/toml.ts
    src/formats/markdown.ts
    src/formats/__tests__/toml.test.ts
    src/formats/__tests__/markdown.test.ts
  </files>
  <action>
Create TOML and Markdown frontmatter parser modules.

**src/formats/toml.ts** — TOML parse/stringify:
- `readToml<T = unknown>(raw: string): T` — uses `parse()` from `smol-toml`. Wraps errors in `ParseError`.
- `writeToml(data: Record<string, unknown>): string` — uses `stringify()` from `smol-toml`, appends trailing newline. Wraps errors in `ParseError`.
- Import `{ parse, stringify }` from `smol-toml`
- Note: TOML comment preservation is NOT supported by any JS library (per research). This is fine for v1 since Gemini TOML configs are generated from scratch, not edited in-place.

**src/formats/markdown.ts** — Markdown frontmatter parse/stringify:
- `parseFrontmatter(raw: string): { data: Record<string, unknown>; content: string }` — uses `matter()` from `gray-matter`. Returns `{ data, content }`. Wraps errors in `ParseError`.
- `stringifyFrontmatter(content: string, data: Record<string, unknown>): string` — uses `matter.stringify(content, data)`. Wraps errors in `ParseError`.
- Import `matter` from `gray-matter`
- Note per research pitfall #5: gray-matter may reorder YAML keys on stringify. This is acceptable — YAML spec says key order is irrelevant. Don't depend on key order for hashing frontmatter.

**Tests (src/formats/__tests__/toml.test.ts):**
- readToml parses valid TOML with strings, numbers, booleans, arrays, nested tables
- readToml throws ParseError on invalid TOML
- writeToml produces valid TOML string with trailing newline
- writeToml → readToml round-trip preserves data types (integer stays integer, not float)
- TOML inline tables and sections both parse correctly

**Tests (src/formats/__tests__/markdown.test.ts):**
- parseFrontmatter extracts data and content from markdown with YAML frontmatter
- parseFrontmatter handles empty frontmatter (just `---\n---`)
- parseFrontmatter handles markdown with no frontmatter (returns empty data, full content)
- parseFrontmatter throws ParseError on malformed YAML
- stringifyFrontmatter produces markdown with YAML frontmatter delimited by `---`
- Round-trip: parseFrontmatter(stringifyFrontmatter(content, data)) preserves data and content
- Content with `---` inside body does not confuse the parser

Follow codebase conventions: camelCase functions, 2-space indent, single quotes.
  </action>
  <verify>
    `bun test src/formats/__tests__/toml.test.ts src/formats/__tests__/markdown.test.ts` — all tests pass
  </verify>
  <done>
    - readToml/writeToml round-trip preserves TOML data types
    - parseFrontmatter/stringifyFrontmatter round-trip preserves frontmatter data and body content
    - Edge cases handled: empty frontmatter, no frontmatter, `---` in body, TOML nested tables
    - All errors wrapped in ParseError with operation context
  </done>
</task>

</tasks>

<verification>
Run full Phase 1 Plan 02 test suite:
```bash
bun test src/formats/__tests__/
```

All tests must pass. Verify:
- Dependencies installed: jsonc-parser, smol-toml, gray-matter in package.json
- JSONC comments survive modify operations (the critical test)
- TOML types are preserved (integers don't become floats)
- Markdown frontmatter round-trips without data loss
- No `any` or `as` in TypeScript
- All errors are ParseError with operation context
</verification>

<success_criteria>
- All 4 test files pass with `bun test`
- JSONC comment preservation works through read-modify-write
- TOML parse/stringify preserves data types
- Markdown frontmatter round-trips cleanly
- All parse errors wrapped in ParseError with context
- 3 dependencies installed and working
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
